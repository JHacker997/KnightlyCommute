<!DOCTYPE html>
<html>
  <head>
    <title>Knightly Commute</title>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src='https://threejs.org/examples/js/libs/dat.gui.min.js'></script>
    <script src= "https://threejs.org/examples/js/loaders/OBJLoader.js"> </script>
    <script src= "https://threejs.org/examples/js/loaders/MTLLoader.js"> </script>


    <script>
       // Add your own Javascript code/methods here.
      const multSize = 2;
      const mapLevel = 74.42;
      function mainFunction()
      {
        let renderer = new THREE.WebGLRenderer( { antialias: true } );//let renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor (0x888888, 1);
        document.body.appendChild( renderer.domElement );

        let scene = new THREE.Scene();

        let aspect = window.innerWidth / window.innerHeight;
        let camera = new THREE.PerspectiveCamera( 50, aspect, 1, 1000 );
        camera.position.y = 150;
        camera.position.z = 5;
        scene.add(camera);

        let light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 100, 1);
        scene.add(light);
        let ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);
          
          let  envLoader = new THREE.CubeTextureLoader();
          envLoader.setPath("./cubeMap/");
          let textureCube = envLoader.load([
              "px.png", "nx.png",
              "py.png", "ny.png",
              "pz.png", "nz.png"
          ]);
          scene.background = textureCube;

        let render = function ()
        {
          renderer.render( scene, camera );
        };

        let cameraControls = new THREE.OrbitControls( camera, renderer.domElement  );
        cameraControls.addEventListener("change", render, false);

        let mtlLoader =  new THREE.MTLLoader();

        mtlLoader.load("./computerDesk/Magis_XZ3_200_mat(1).mtl", function(materials){
          materials.preload();

          let objLoader = new THREE.OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.load("./computerDesk/Magis_XZ3_200_mat(1).obj", function(obj){
            obj.position.x = 10;
            obj.rotation.x = -Math.PI / 2;
            obj.rotation.z = Math.PI / 2;
            scene.add(obj);
            render();
          });
        });

        let texture = THREE.ImageUtils.loadTexture( "mapper.png" );
        let material = new THREE.MeshLambertMaterial({ map : texture });
        let wood = new THREE.TextureLoader().load("./woodTex.png");
        let floorMaterial = new THREE.MeshLambertMaterial({side: THREE.DoubleSide, map: wood});
        let plane = new THREE.Mesh(new THREE.PlaneGeometry(21.6*multSize, 28.275*multSize), material);
        let floorplane = new THREE.Mesh(new THREE.PlaneGeometry(400, 200), floorMaterial);
        plane.rotation.x = Math.PI / 2;
        plane.rotation.z = Math.PI;
        plane.rotation.y = Math.PI;

        scene.add(plane);
        
        let cylinderGeometry = new THREE.CylinderGeometry(0.2*multSize, 0.2*multSize, 2*multSize);
        let intermedMaterial = new THREE.MeshLambertMaterial({color:0x00ff00});
        let nodeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
        let cylinderArray = [];
        let intermedNodesArray = new Array();
        let numNodes = 22;
        for(let i = 0; i < numNodes; i++)
        {
          cylinderArray.push(new THREE.Mesh(cylinderGeometry, nodeMaterial));
          scene.add(cylinderArray[i]);
        }

        cylinderArray[0].position.set(1.7*multSize, mapLevel, -0.42*multSize);
        cylinderArray[1].position.set(-0.48*multSize, mapLevel, 1.3*multSize);
        cylinderArray[2].position.set(-4.15*multSize, mapLevel, 0.95*multSize);
        cylinderArray[3].position.set(-6.8*multSize, mapLevel, -0.10*multSize);
        cylinderArray[4].position.set(-6.7*multSize, mapLevel, -3.55*multSize);
        cylinderArray[5].position.set(-4.75*multSize, mapLevel, -7.5*multSize);
        cylinderArray[6].position.set(0.5*multSize, mapLevel, -7.6*multSize);
        cylinderArray[7].position.set(1.61*multSize, mapLevel, -7.35*multSize);
        cylinderArray[8].position.set(2.3*multSize, mapLevel, -6.29*multSize);
        cylinderArray[9].position.set(2.62*multSize, mapLevel, -5.22*multSize);
        cylinderArray[10].position.set(3.55*multSize, mapLevel, -3.85*multSize);
        cylinderArray[11].position.set(6.2*multSize, mapLevel, -12.2*multSize);
        cylinderArray[12].position.set(-8.9*multSize, mapLevel, -12.2*multSize);
        cylinderArray[13].position.set(-8.9*multSize, mapLevel, -8.4*multSize);
        cylinderArray[14].position.set(-8.9*multSize, mapLevel, -3.35*multSize);
        cylinderArray[15].position.set(-8.77*multSize, mapLevel, 1.22*multSize);
        cylinderArray[16].position.set(-9.3*multSize, mapLevel, 5.45*multSize);
        cylinderArray[17].position.set(-9.1*multSize, mapLevel, 11.2*multSize);
        cylinderArray[18].position.set(-1.29*multSize, mapLevel, 10.8*multSize);
        cylinderArray[19].position.set(5.8*multSize, mapLevel, 8.3*multSize);
        cylinderArray[20].position.set(3.55*multSize, mapLevel, 5.2*multSize);
        cylinderArray[21].position.set(3.17*multSize, mapLevel, 2.62*multSize);
        

        let linematerial;

        let lineGeometryArray = new Array();
        let lineMathArray = new Array();

        function createLineVector(v1, v2, index, addPoints) {
           linematerial = new THREE.LineBasicMaterial({color: 0x0000ff});

           let numLines = 0;

          let liner = new THREE.Geometry();

          lineGeometryArray[index] = new Array();
          lineMathArray[index] = new Array();
          if(addPoints != null)
          {
            let point1 = new THREE.Vector3(v1.x, 74.8, v1.z);
            liner.vertices.push(
              point1
            );
            
            let pointsLine = 1;
            let numPoints = addPoints.length;
            for(let i = 0; i < numPoints; i++)
            {
              let point2 = new THREE.Vector3(addPoints[i].position.x, 74.8, addPoints[i].position.z);
              liner.vertices.push(
                point2
              );
              pointsLine++;
              if(pointsLine == 2)
              {
                lineMathArray[index].push(new THREE.Line3(point1, point2));
                lineGeometryArray[index].push(new THREE.Line(liner, linematerial ));
                scene.add(lineGeometryArray[index][numLines++]);
                point1 = new THREE.Vector3(addPoints[i].position.x, 74.8, addPoints[i].position.z);
                liner.vertices.push(
                  point1
                );
                pointsLine = 1;
              }
            }
            point2 =  new THREE.Vector3(v2.x, 74.8, v2.z);
            liner.vertices.push(
              point2
            );
            pointsLine++;

            if(pointsLine == 2)
              {
                lineMathArray[index].push(new THREE.Line3(point1, point2));
                lineGeometryArray[index].push(new THREE.Line(liner, linematerial ));
                scene.add(lineGeometryArray[index][numLines++]);
                pointsLine = 1;
              }

          }
          else
          {
            liner.vertices.push(
              new THREE.Vector3(v1.x, 74.8, v1.z),
              new THREE.Vector3(v2.x, 74.8, v2.z)
            );
            lineGeometryArray[index].push(new THREE.Line(liner, linematerial ));
          scene.add(lineGeometryArray[index][numLines]);
          } 
          
        }
        
        let numEdges = 0;

        // intermediary nodes
        let numPerTier = [];
        function createInterNodes(numInt, indexTier)
        {
          numPerTier.push(numInt);
          intermedNodesArray[indexTier] = new Array();
          for(let i = 0; i < numPerTier[indexTier]; i++)
          {
            intermedNodesArray[indexTier].push(new THREE.Mesh(cylinderGeometry, intermedMaterial));
            scene.add(intermedNodesArray[indexTier][i]);
          }
        }
        createInterNodes(2, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[1].position.x + 3, mapLevel, cylinderArray[0].position.z + 2);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[1].position.x + 2, mapLevel, cylinderArray[1].position.z - 0.5);

        createLineVector(cylinderArray[0].position, cylinderArray[1].position, numEdges++, intermedNodesArray[0]);

        createInterNodes(1, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[1].position.x - 2, mapLevel, cylinderArray[1].position.z + 0.75);

        createLineVector(cylinderArray[1].position, cylinderArray[2].position, numEdges++, intermedNodesArray[1]);
        
        createInterNodes(0, numEdges);

        createLineVector(cylinderArray[2].position, cylinderArray[3].position, numEdges++);

        createInterNodes(3, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[3].position.x - 1.8, mapLevel, cylinderArray[3].position.z - 2.5);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[3].position.x - 1.5, mapLevel, cylinderArray[3].position.z - 4);
        intermedNodesArray[numEdges][2].position.set(cylinderArray[3].position.x - 0.5, mapLevel, cylinderArray[3].position.z - 5.5);
        
        createLineVector(cylinderArray[3].position, cylinderArray[4].position, numEdges++, intermedNodesArray[3]);

        createInterNodes(4, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[4].position.x - 1, mapLevel, cylinderArray[4].position.z - 2);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[4].position.x - 1.5, mapLevel, cylinderArray[4].position.z - 3);
        intermedNodesArray[numEdges][2].position.set(cylinderArray[4].position.x - 1.5, mapLevel, cylinderArray[4].position.z - 4);
        intermedNodesArray[numEdges][3].position.set(cylinderArray[4].position.x + 1, mapLevel, cylinderArray[4].position.z - 6);
        
        createLineVector(cylinderArray[4].position, cylinderArray[5].position, numEdges++, intermedNodesArray[4]);

        createInterNodes(4, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[5].position.x + 1.5, mapLevel, cylinderArray[5].position.z + 1.2);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[5].position.x + 2.7, mapLevel, cylinderArray[5].position.z + 1.5);
        intermedNodesArray[numEdges][2].position.set(cylinderArray[5].position.x + 4, mapLevel, cylinderArray[5].position.z + 1.3);
        intermedNodesArray[numEdges][3].position.set(cylinderArray[5].position.x + 7, mapLevel, cylinderArray[5].position.z + 0.5);
        
        createLineVector(cylinderArray[5].position, cylinderArray[6].position, numEdges++, intermedNodesArray[5]);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[6].position, cylinderArray[7].position, numEdges++);

        createInterNodes(1, numEdges);
        
        intermedNodesArray[numEdges][0].position.set(cylinderArray[7].position.x + 1, mapLevel, cylinderArray[7].position.z + 1);
        
        createLineVector(cylinderArray[7].position, cylinderArray[8].position, numEdges++, intermedNodesArray[7]);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[8].position, cylinderArray[9].position, numEdges++);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[8].position.x + 2, mapLevel, cylinderArray[9].position.z + 1.5);
        
        createLineVector(cylinderArray[9].position, cylinderArray[10].position, numEdges++, intermedNodesArray[9]);

         createInterNodes(2, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[10].position.x + 0.4, mapLevel, cylinderArray[10].position.z + 2);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[10].position.x - 0.3, mapLevel, cylinderArray[10].position.z + 4);
        
        createLineVector(cylinderArray[10].position, cylinderArray[0].position, numEdges++, intermedNodesArray[10]);

        createInterNodes(8, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[11].position.x - 3, mapLevel, cylinderArray[8].position.z - 1.5);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[11].position.x + 0.5, mapLevel, cylinderArray[8].position.z - 1.8);
        intermedNodesArray[numEdges][2].position.set(cylinderArray[11].position.x + 2, mapLevel, cylinderArray[8].position.z - 2.5);
        intermedNodesArray[numEdges][3].position.set(cylinderArray[11].position.x + 2.8, mapLevel, cylinderArray[8].position.z - 4);
        intermedNodesArray[numEdges][4].position.set(cylinderArray[11].position.x + 2.4, mapLevel, cylinderArray[8].position.z - 5.5);
        intermedNodesArray[numEdges][5].position.set(cylinderArray[11].position.x + 1.5, mapLevel, cylinderArray[8].position.z - 7);
        intermedNodesArray[numEdges][6].position.set(cylinderArray[11].position.x + 0.5, mapLevel, cylinderArray[8].position.z - 8.8);

        intermedNodesArray[numEdges][7].position.set(cylinderArray[7].position.x + 9, mapLevel, cylinderArray[7].position.z - 8);
        
        createLineVector(cylinderArray[8].position, cylinderArray[11].position, numEdges++, intermedNodesArray[11]);


        createInterNodes(4, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[7].position.x + 3, mapLevel, cylinderArray[7].position.z - 4.8);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[7].position.x + 5.5, mapLevel, cylinderArray[7].position.z - 6.4);
        intermedNodesArray[numEdges][2].position.set(cylinderArray[7].position.x + 5.5, mapLevel, cylinderArray[7].position.z - 7.7);
        intermedNodesArray[numEdges][3].position.set(cylinderArray[7].position.x + 9, mapLevel, cylinderArray[7].position.z - 8);
        
        createLineVector(cylinderArray[7].position, cylinderArray[11].position, numEdges++, intermedNodesArray[12]);

        createInterNodes(4, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[6].position.x + 3.2, mapLevel, cylinderArray[6].position.z - 6.4);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[6].position.x + 5.5, mapLevel, cylinderArray[6].position.z - 7.3);

        intermedNodesArray[numEdges][2].position.set(cylinderArray[7].position.x + 5.5, mapLevel, cylinderArray[7].position.z - 7.7);
        intermedNodesArray[numEdges][3].position.set(cylinderArray[7].position.x + 9, mapLevel, cylinderArray[7].position.z - 8);
        
        createLineVector(cylinderArray[6].position, cylinderArray[11].position, numEdges++, intermedNodesArray[13]);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[11].position, cylinderArray[12].position, numEdges++);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[12].position, cylinderArray[13].position, numEdges++);

        createInterNodes(2, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[13].position.x + 5, mapLevel, cylinderArray[13].position.z);
        intermedNodesArray[numEdges][1].position.set(cylinderArray[13].position.x + 7, mapLevel, cylinderArray[13].position.z + 0.5);
        
        createLineVector(cylinderArray[13].position, cylinderArray[5].position, numEdges++, intermedNodesArray[16]);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[13].position, cylinderArray[14].position, numEdges++);

        createInterNodes(0, numEdges);
        
        createLineVector(cylinderArray[14].position, cylinderArray[4].position, numEdges++);
        
        createInterNodes(0, numEdges);

        createLineVector(cylinderArray[14].position, cylinderArray[15].position, numEdges++);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[15].position.x + 2, mapLevel, cylinderArray[15].position.z - 1);
        
        createLineVector(cylinderArray[15].position, cylinderArray[3].position, numEdges++, intermedNodesArray[20]);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[15].position.x, mapLevel, cylinderArray[15].position.z + 5);
        
        createLineVector(cylinderArray[15].position, cylinderArray[16].position, numEdges++, intermedNodesArray[21]);

        createInterNodes(2, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[16].position.x + 4, mapLevel, cylinderArray[16].position.z);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[16].position.x + 5.9, mapLevel, cylinderArray[16].position.z - 1.5);
        
        createLineVector(cylinderArray[16].position, cylinderArray[2].position, numEdges++, intermedNodesArray[22]);

        createInterNodes(3, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[16].position.x - 0.8, mapLevel, cylinderArray[16].position.z + 2.5);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[16].position.x - 1.2, mapLevel, cylinderArray[16].position.z + 5);

        intermedNodesArray[numEdges][2].position.set(cylinderArray[16].position.x - 1, mapLevel, cylinderArray[16].position.z + 8);
        
        createLineVector(cylinderArray[16].position, cylinderArray[17].position, numEdges++, intermedNodesArray[23]);

        createInterNodes(4, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[17].position.x + 6, mapLevel, cylinderArray[17].position.z - 1.3);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[17].position.x + 8, mapLevel, cylinderArray[17].position.z - 2.1);

        intermedNodesArray[numEdges][2].position.set(cylinderArray[17].position.x + 10, mapLevel, cylinderArray[17].position.z - 3.2);

        intermedNodesArray[numEdges][3].position.set(cylinderArray[17].position.x + 13, mapLevel, cylinderArray[17].position.z - 2.8);
        
        createLineVector(cylinderArray[17].position, cylinderArray[18].position, numEdges++, intermedNodesArray[24]);

        createInterNodes(2, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[18].position.x + 3.5, mapLevel, cylinderArray[17].position.z + 0.1);

        intermedNodesArray[numEdges][1].position.set(cylinderArray[18].position.x + 6.5, mapLevel, cylinderArray[17].position.z - 0.8);
        
        createLineVector(cylinderArray[18].position, cylinderArray[19].position, numEdges++, intermedNodesArray[25]);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[19].position.x - 0.5, mapLevel, cylinderArray[19].position.z - 4);
        
        createLineVector(cylinderArray[19].position, cylinderArray[20].position, numEdges++, intermedNodesArray[26]);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[20].position.x - 0.9, mapLevel, cylinderArray[20].position.z - 2.4);

        createLineVector(cylinderArray[20].position, cylinderArray[21].position, numEdges++, intermedNodesArray[27]);

        createInterNodes(1, numEdges);

        intermedNodesArray[numEdges][0].position.set(cylinderArray[21].position.x - 0.5, mapLevel, cylinderArray[21].position.z - 3);
        
        createLineVector(cylinderArray[21].position, cylinderArray[0].position, numEdges++, intermedNodesArray[28]);
        
		//Nestor's code
		function Edge(length, lines) {
			this.length = length;
			this.lines = lines;
		}
		
		var _ = Infinity;
		
		var adjacencies = [
		//  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21
          [ _, 0, _, _, _, _, _, _, _, _,10, _, _, _, _, _, _, _, _, _, _,28 ],//0
          [ 0, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ ],//1
		  [ _, 1, _, 2, _, _, _, _, _, _, _, _, _, _, _, _,22, _, _, _, _, _ ],//2
		  [ _, _, 2, _, 3, _, _, _, _, _, _, _, _, _, _,20, _, _, _, _, _, _ ],//3
		  [ _, _, _, 3, _, 4, _, _, _, _, _, _, _, _,18, _, _, _, _, _, _, _ ],//4
		  [ _, _, _, _, 4, _, 5, _, _, _, _, _, _,16, _, _, _, _, _, _, _, _ ],//5
		  [ _, _, _, _, _, 5, _, 6, _, _, _,13, _, _, _, _, _, _, _, _, _, _ ],//6
		  [ _, _, _, _, _, _, 6, _, 7, _, _,12, _, _, _, _, _, _, _, _, _, _ ],//7
		  [ _, _, _, _, _, _, _, 7, _, 8, _,11, _, _, _, _, _, _, _, _, _, _ ],//8
		  [ _, _, _, _, _, _, _, _, 8, _, 9, _, _, _, _, _, _, _, _, _, _, _ ],//9
		  [10, _, _, _, _, _, _, _, _, 9, _, _, _, _, _, _, _, _, _, _, _, _ ],//10
		  [ _, _, _, _, _, _,13,12,11, _, _, _,14, _, _, _, _, _, _, _, _, _ ],//11
		  [ _, _, _, _, _, _, _, _, _, _, _,14, _,15, _, _, _, _, _, _, _, _ ],//12
		  [ _, _, _, _, _,16, _, _, _, _, _, _,15, _,17, _, _, _, _, _, _, _ ],//13
		  [ _, _, _, _,18, _, _, _, _, _, _, _, _,17, _,19, _, _, _, _, _, _ ],//14
		  [ _, _, _,20, _, _, _, _, _, _, _, _, _, _,19, _,21, _, _, _, _, _ ],//15
		  [ _, _,22, _, _, _, _, _, _, _, _, _, _, _, _,21, _,23, _, _, _, _ ],//16
		  [ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,23, _,24, _, _, _ ],//17
		  [ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,24, _,25, _, _ ],//18
		  [ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,25, _,26, _ ],//19
		  [ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,26, _,27 ],//20
		  [28, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,27, _ ] //21
        ];
		
		var edgeMatrix = [...Array(adjacencies.length)].map(e => Array(adjacencies.length));
		
		
		for(i = 0; i < adjacencies.length; i++){
			for(j = 0; j < adjacencies[0].length; j++){
				if (adjacencies[i][j] != Infinity){
					edgeMatrix[i][j] = new Edge(cylinderArray[i].position.distanceTo(cylinderArray[j].position), lineGeometryArray[adjacencies[i][j]]);
					edgeMatrix[j][i] = edgeMatrix[i][j];
				}
			}
		}
		
		
		
        plane.position.set(0, 74.6, 0);
          floorplane.rotation.x = Math.PI / 2;
          floorplane.rotation.z = Math.PI;
          floorplane.rotation.y = Math.PI;
          floorplane.position.set(5, -1, 0);
          scene.add(floorplane);
    

        render();
		
		function colorChange(index, color, numLines) {
			lineGeometryArray[index].forEach(function(line){
        line.material.color = new THREE.Color(color);
			 line.material.needsUpdate = true;
			render();});
		};
		
        let resize = function ()
        {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          render();
        };

        //console.log(lineMathArray[0][0].distance());

        //colorChange(0, 0xff0000);

        window.addEventListener("resize",resize, false)
      }
    </script>
  </head>
  <body onload="mainFunction();">
  <h1>Knightly Commute</h1>
  </body>
</html>
