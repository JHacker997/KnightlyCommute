<!DOCTYPE html>
<html>
  <head>
    <title>Knightly Commute</title>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src='https://threejs.org/examples/js/libs/dat.gui.min.js'></script>
    <script src= "https://threejs.org/examples/js/loaders/OBJLoader.js"> </script>
    <script src= "https://threejs.org/examples/js/loaders/MTLLoader.js"> </script>


    <script>
       // Add your own Javascript code/methods here.
      function mainFunction()
      {
        let renderer = new THREE.WebGLRenderer( { antialias: true } );//let renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor (0x888888, 1);
        document.body.appendChild( renderer.domElement );

        let scene = new THREE.Scene();

        let aspect = window.innerWidth / window.innerHeight;
        let camera = new THREE.PerspectiveCamera( 50, aspect, 1, 1000 );
        camera.position.y = 70;
        camera.position.z = 5;
        scene.add(camera);

        let light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 50, 1);
        scene.add(light);

        let render = function ()
        {
          renderer.render( scene, camera );
        };

        let cameraControls = new THREE.OrbitControls( camera, renderer.domElement  );
        cameraControls.addEventListener("change", render, false);

        let mat = new THREE.MeshPhongMaterial({color: 0x2194ce})

        // once material is read initiate the obj Loading
        let objLoader = new THREE.OBJLoader();
        let table;
        // load a resource
        objLoader.load('table.obj' ,function(object)
        {
          object.position.x = 10;
          object.material = mat;
          table = object;
          scene.add( object );
          render(); // may be make a call to your render function
        })

        let texture = THREE.ImageUtils.loadTexture( "map.png" );
        let material = new THREE.MeshLambertMaterial({ map : texture });
        let plane = new THREE.Mesh(new THREE.PlaneGeometry(23.2, 30), material);
        plane.rotation.x = Math.PI / 2;
        plane.rotation.z = Math.PI;
        plane.rotation.y = Math.PI;
        scene.add(plane);
        plane.position.set(0, 32, 0);

        render();

        let resize = function ()
        {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          render();
        };

        window.addEventListener("resize",resize, false)



        var _ = Infinity;
        var e = [
          [ _, 2, _, _, 1, 5, _, _, _, _, _ ],
          [ 2, _, 3, _, _, _, _, _, _, _, _ ],
          [ _, 3, _, 8, _, _, _, _, _, _, _ ],
          [ _, _, 8, _, _, _, _, _, _, _, _ ],
          [ 1, _, _, _, _, 2, 5, _, _, _, _ ],
          [ 5, _, _, _, 2, _, 3, _, _, _, _ ],
          [ _, _, _, _, 5, 3, _, 2, _, _, _ ],
          [ _, _, _, _, _, _, 2, _, 7, _, _ ],
          [ _, _, _, _, _, _, _, 7, _, 1, 5 ],
          [ _, _, _, _, _, _, _, _, 1, _, 3 ],
          [ _, _, _, _, _, _, _, _, 5, 3, _ ]
        ];

        // Compute the shortest paths from vertex number 1 to each other vertex
        // in the graph.
        var shortestPathInfo = shortestPath(e, 11, 0, 10);

        // Get the shortest path from vertex 1 to vertex 6.
        // var path1to6 = constructPath(shortestPathInfo, 6);

        console.log(shortestPathInfo);
        //console.log(path1to6);


    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function shortestPath(edges, numVertices, startVertex, endVertex) {

    var done = new Array(numVertices);
      done[startVertex] = true;
      var pathLengths = new Array(numVertices);
      var predecessors = new Array(numVertices);


      for (var i = 0; i < numVertices; i++) {
        // If there is an edge between the starting vertex and this vertex, set the shortest path equal to that path length
        pathLengths[i] = edges[startVertex][i];

        // If we do, set the parent of the end node to the start node
        if (edges[startVertex][i] != Infinity) {

            // Pause here and light up edges[startVertex][i]
            // Light up pathLengths[i]
            console.log("Initializing path [" + startVertex + "][" + i + "]" + " to " + pathLengths[i]);
            await sleep(1000);
            


            predecessors[i] = startVertex;
        }
      }

      // The distance from the start node to itself is always 0
    pathLengths[startVertex] = 0;


      for (var i = 0; i < numVertices - 1; i++) {
        var closest = -1;
        var closestDistance = Infinity;
        for (var j = 0; j < numVertices; j++) {
          // If we haven't yet looked at this node and the path length currently
          // stored is smaller than the closestDistance
            if (!done[j] && pathLengths[j] < closestDistance) {

              // The new closest distance is the current path length
              closestDistance = pathLengths[j];

              // j is the closest node
              closest = j;
            }
        }

        // PAUSE: light up edges[predecessor[closest]][closest]
          // temp = closest
          // while (temp != startVertex)
          //    light up temp[predecessor[temp]][temp]
          //    temp = predecessor[temp]

          var temp = closest;
          while (temp != startVertex){
              console.log("Light up [" + predecessors[temp] + "][" + temp + "]");
              temp = predecessors[temp];
          }

          await sleep(3000);

        // we've looked at the closest node
        done[closest] = true;


        for (var j = 0; j < numVertices; j++) {

          // If we haven't looked at this node yet
            if (!done[j]) {

              // Take the current closest path length and add the edge between the
              // closest node and this one
              var possiblyCloserDistance = pathLengths[closest] + edges[closest][j];

              // PAUSE: light up edges[closest][j]
              if (edges[closest][j] != Infinity){
                console.log("Currently inspecting edge between [" + closest + "] and [" + j + "]");
                await sleep(1000);
              }

              // If this distance is shorter than the current stored path length
              if (possiblyCloserDistance < pathLengths[j]) {

                // Replace the path length with the shorter one and set the parent of this node to the closest node

                // PAUSE: light up pathlength[j]
                console.log("Changing shortest pathlength of " + j + " from " +pathLengths[j] + " to " + possiblyCloserDistance);

                await sleep(1000);

                // unlight edges[closest][j] and pathlength[j]

                  pathLengths[j] = possiblyCloserDistance;
                  predecessors[j] = closest;
              }
            }
        }

        // POTENTIAL PAUSE: light up red pathlengths[closest] to mark it done

          // temp = closest
          // while (temp != startVertex)
          //    UNlight up temp[predecessor[temp]][temp]
          //    temp = predecessor[temp]
      }

      constructPath({ "startVertex": startVertex,
               "pathLengths": pathLengths,
               "predecessors": predecessors }, endVertex);

      return { "startVertex": startVertex,
               "pathLengths": pathLengths,
               "predecessors": predecessors };
  }

  function constructPath(shortestPathInfo, endVertex) {
    // Empty array to store our path from start to end node
      var path = [];

      // We must work backwards from the end node and through the parents of the nodes
      // to construct the path
      while (endVertex != shortestPathInfo.startVertex) {
        // Unshift just adds the element to the beginning of the array
        path.unshift(endVertex);

        // Light up edges[predecessors[endVertex][endVertex]


        // Once we've added the current node, we move on to the parent node
        endVertex = shortestPathInfo.predecessors[endVertex];
      }

      console.log(path);

      return path;
  }


    </script>
  </head>
  <body onload="mainFunction();">
  <h1>John Hacker ID=jo486831</h1>
  </body>
</html>
